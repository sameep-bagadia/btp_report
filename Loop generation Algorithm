/*
A, B are the sets of points representing partition P(A, B) which we are characterizing by loops using the algorithm
boundaries contains the upper limit of the index variables
l denotes the current loop nest level.
*/
Algorithm generate_loop (A, B, boundaries, l) {

	A = sort_and_dominate(A)
	B = sort_and_dominate(B)

	//BASE CASE
	if A and B have points with only 1 dimension then {
		start = A.first()[0];
		if (B is empty) {
			end = boundarie[l];
		}
		else {
			end = B.first()[0] - 1;
		}
		put forall i_l = start to end
		put all the statements to be executed
		put endall

		return;
	}
	
	A' = empty
	B' = empty
	start = min (A.first()[0], B.first())
	
	while (A is not empty or B is not empty) {
		
		while (A.first()[0] == start) {
			remove first point from A and put it in A' after removing the first dimension from it
			// eg: if first point is (2, 4, 1), then put (4, 1) in A'
		}
		while (B.first()[0] == start) {
			remove first point from B and put it in B' after removing the first dimension from it
		}

		if (both A and B are empty) {
			end = boundaries[l];
		}
		else {
			end = min(A.first()[0], B.first()[0]) - 1;
		}

		put forall i_l = start to end
		generate_loop (A', B', boundaries, l+1);
		put endall

		start = end + 1
	}
}	

sort_and_dominate() sorts all the points on the first dimension and also removes redundant points, i.e., if a,b belongs A and a <= b then b is removed from A.


Example:

Proof:


Notation:
[a:b] denotes the vector obtained on inserting element a at front of vector b.
For example [1:(2, 3, 4)] denotes (1, 2, 3, 4)

Lemma1:
If a > b then [a:x] not <= [b:y] for any x, y

Lemma2:
If a <= b and x <= y
then [x:a] <= [y:b]
This is straightforward from the definition of <=

Lemma3
If not(a <= b)
then for all x,y, not([x:a] <= [y:b])
This is straightforward from the definition of <=

The proofs for these lemmas are straightforward from the definition of <=

We need to prove that set of points in P(A, B) and those generated by this algorithm are same.
Here P(A, B) = {x| bla bla}
The proof is based on induction on the dimension of the points.

Base case (dimension = 1) :
When dimension is one, there can be exactly one point (say a) in set A and at most one point (say b) in B after removing redundant points. Thus, P(A, B) contains iteration points from a to b-1 when b exists. Otherwise it contains iteration points from a to boundary. The same thing is there in the algorithm also. Thus base case is correct.

Induction case:

For each value of x, 
For all a in A such that, x < first(a)
a not <= [x:y] for any y (by Lemma1). 
Therefore These a's need not be considered.
We have A' = {a in A, first(a) <= x}. By induction the partition will include those y where exists a' in A' such that a' <= y
By Lemma2, as first(a) <= x for all a in A' and there exists a' in A' such that a' <= y, exists a in A st a <= [x:y]

For all b in B st first(b) > x, b not <= [x:y] for any y by Lemma1.
B' includes all b in B st first(b) <= x.
By induction, it will include only those points y where y not <= b' for all b' in B'
y not <= b' => [x:y] <= [first(b):b']  (by Lemma 3)
Thus, for all b in B, [x:y] not <= b.

Thus, all the points included by the algorithm is same as the set of points defined by P(A,B)





	
